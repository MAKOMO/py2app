""" """
import types
import typing

DEFAULT_IMPORT_LEVEL: int

# This is a type defined in altgraph, for now
# I'm not bothering with creating stubs for this
# type.
class Graph(typing.Protocol):
    def node_list(self) -> typing.Iterator[str]: ...

class Node:
    debug: int
    graphident: str | None
    identifier: str
    filename: str | None
    packagepath: list[str] | None
    code: types.CodeType | None
    globalnames: set[str]
    starimports: set[str]
    path: list[str]

    # XXX: Custom attributes in py2app
    _py2app_global_reads: typing.Set[str]
    _py2app_global_writes: typing.Set[str]

    def __contains__(self, name: str) -> bool: ...
    def __getitem__(self, name: str) -> typing.Any: ...
    def __setitem__(self, name: str, value: typing.Any) -> None: ...
    def get(self, name: str, default: typing.Any = None) -> typing.Any: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def infoTuple(self) -> tuple[str]: ...
    def __repr__(self) -> str: ...

class Alias: ...
class AliasNode(Node): ...
class BadModule(Node): ...
class ExcludedModule(BadModule): ...
class MissingModule(BadModule): ...
class InvalidRelativeImport(BadModule): ...
class Script(Node): ...
class BaseModule(Node): ...
class BuiltinModule(BaseModule): ...
class SourceModule(BaseModule): ...
class InvalidSourceModule(SourceModule): ...
class CompiledModule(BaseModule): ...
class InvalidCompiledModule(BaseModule): ...
class Package(BaseModule): ...
class NamespacePackage(Package): ...
class Extension(BaseModule): ...
class FlatPackage(BaseModule): ...
class ArchiveModule(BaseModule): ...
class RuntimeModule(MissingModule): ...

class ModuleGraph:
    replace_paths: typing.Sequence[str] | None
    graph: Graph
    lazynodes: typing.Dict[str, Alias | typing.Tuple[str, ...] | None]

    def __init__(
        self,
        path: list[str] | None = None,
        excludes: typing.Sequence[str] = (),
        replace_paths: typing.Sequence[str] | None = (),
        implies: typing.Sequence[str] | None = (),
        graph: typing.Any = None,
        debug: int = 0,
    ): ...
    def findNode(self, node: str | Node | None) -> Node | None: ...
    def _replace_paths_in_code(self, co: types.CodeType) -> types.CodeType: ...
    def _scan_code(self, co: types.CodeType, m: Node) -> None: ...
    def flatten(self) -> typing.Iterator[Node]: ...
    def import_hook(
        self,
        name: str,
        caller: Node | None = None,
        fromlist: typing.Sequence[str] | None = None,
        level: int = DEFAULT_IMPORT_LEVEL,
        attr: object | None = None,
    ) -> Node: ...
    def removeReference(self, fromnode: Node | str, tonode: Node | str) -> None: ...
    def run_script(
        self, pathname: str, caller: typing.Optional[Node] = None
    ) -> Node: ...

def find_module(
    name: str, path: str | None = None
) -> tuple[typing.IO[bytes] | None, str, tuple[str, str, int]]: ...
